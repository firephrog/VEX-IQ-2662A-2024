{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nleft_drive_smart = Motor(Ports.PORT1, 1.0, False)\nright_drive_smart = Motor(Ports.PORT7, 1.0, True)\n\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 200)\ngyro_6 = Gyro(Ports.PORT6)\nintake_motor_a = Motor(Ports.PORT3, False)\nintake_motor_b = Motor(Ports.PORT9, True)\nintake = MotorGroup(intake_motor_a, intake_motor_b)\nelevator_motor_a = Motor(Ports.PORT2, True)\nelevator_motor_b = Motor(Ports.PORT8, False)\nelevator = MotorGroup(elevator_motor_a, elevator_motor_b)\ntouchled_4 = Touchled(Ports.PORT4)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# -----------------------------------------------\n# This version does not use the second distance sensor. \n# The running process is left purple -> right purple -> shoot -> yellow ->extension\n# -----------------------------------------------\n# \n# Library imports\nfrom vex import *\n\ndef GyroTurn(heading_angle, heading_velocity, heading_momentum):\n    if heading_angle > gyro_6.rotation(DEGREES):  # turning left\n        while heading_angle - heading_momentum > gyro_6.rotation(DEGREES):\n            left_drive_smart.set_velocity(heading_velocity,PERCENT)\n            right_drive_smart.set_velocity(heading_velocity,PERCENT)\n            left_drive_smart.spin(REVERSE) # left turn\n            right_drive_smart.spin(FORWARD)\n    else:\n        while heading_angle + heading_momentum < gyro_6.rotation(DEGREES):\n            left_drive_smart.set_velocity(heading_velocity,PERCENT)\n            right_drive_smart.set_velocity(heading_velocity,PERCENT)\n            left_drive_smart.spin(FORWARD) # left turn\n            right_drive_smart.spin(REVERSE)\n\n    left_drive_smart.stop(HOLD)\n    right_drive_smart.stop(HOLD)\n\ndef PStraight(robot_distance, robot_heading, robot_velocity, kp):\n    left_drive_smart.set_position(0,DEGREES)\n    right_drive_smart.set_position(0,DEGREES)\n    if robot_velocity > 0: # go to forward \n        while (left_drive_smart.position(DEGREES)<robot_distance):# or (RightMoter.position(DEGREES)<robot_distance):\n            error = robot_heading - gyro_6.rotation(DEGREES) # going forward, not reach the task\n            output = error*kp\n            left_drive_smart.set_velocity(robot_velocity-output, PERCENT)\n            right_drive_smart.set_velocity(robot_velocity+output, PERCENT)\n            left_drive_smart.spin(FORWARD)\n            right_drive_smart.spin(FORWARD)\n\n    else: # go backward\n        while (left_drive_smart.position(DEGREES)>robot_distance):# or (RightMoter.position(DEGREES)>robot_distance):\n            error = robot_heading - gyro_6.rotation(DEGREES) # back up not reach the task\n            output = error*kp\n            left_drive_smart.set_velocity(robot_velocity-output, PERCENT)\n            right_drive_smart.set_velocity(robot_velocity+output, PERCENT)\n            left_drive_smart.spin(FORWARD)\n            right_drive_smart.spin(FORWARD)\n       \n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n\ndef PStraightHold(robot_distance, robot_heading, robot_velocity, kp):\n    left_drive_smart.set_position(0,DEGREES)\n    right_drive_smart.set_position(0,DEGREES)\n    if robot_velocity > 0: # go to forward \n        while (left_drive_smart.position(DEGREES)<robot_distance):# or (RightMoter.position(DEGREES)<robot_distance):\n            error = robot_heading - gyro_6.rotation(DEGREES) # going forward, not reach the task\n            output = error*kp\n            left_drive_smart.set_velocity(robot_velocity-output, PERCENT)\n            right_drive_smart.set_velocity(robot_velocity+output, PERCENT)\n            left_drive_smart.spin(FORWARD)\n            right_drive_smart.spin(FORWARD)\n\n    else: # go backward\n        while (left_drive_smart.position(DEGREES)>robot_distance):# or (RightMoter.position(DEGREES)>robot_distance):\n            error = robot_heading - gyro_6.rotation(DEGREES) # back up not reach the task\n            output = error*kp\n            left_drive_smart.set_velocity(robot_velocity-output, PERCENT)\n            right_drive_smart.set_velocity(robot_velocity+output, PERCENT)\n            left_drive_smart.spin(FORWARD)\n            right_drive_smart.spin(FORWARD)\n       \n    left_drive_smart.stop(HOLD)\n    right_drive_smart.stop(HOLD)\n    \n\ndef DriveTrainMove(drive_distance, drive_direction, drive_velocity, timeout):\n    drivetrain.set_drive_velocity(drive_velocity, PERCENT)\n    drivetrain.set_timeout(timeout, SECONDS)\n    drivetrain.drive_for(drive_direction, drive_distance, MM)\n    drivetrain.stop(BRAKE)\n\ndef DriveTrainMoveandStop(drive_distance, drive_direction, drive_velocity, timeout):\n    drivetrain.set_drive_velocity(drive_velocity, PERCENT)\n    drivetrain.set_timeout(timeout, SECONDS)\n    drivetrain.drive_for(drive_direction, drive_distance, MM)\n    drivetrain.stop(HOLD)    \n\n\ndef prepMotors():\n    intake.set_velocity(100,PERCENT)\n    elevator.set_velocity(100,PERCENT)\n    intake.set_max_torque(100,PERCENT)\n    elevator.set_velocity(100,PERCENT)\n    elevator.set_timeout(2,SECONDS)\n\n\ndef Intake4Greens1(drivetrain_velocity):\n    intake.spin(REVERSE)\n    wait(0.1, SECONDS)\n    PStraight(480, 0, drivetrain_velocity, 3)\n    wait(0.1, SECONDS)\n    PStraight(190, 0, 50, 3)\n    wait(0.1, SECONDS)\n\ndef KnockDownRed1(v1, v2):\n    GyroTurn(120, v1, 8)\n    wait(0.1, SECONDS)\n    PStraight(-130, 120, -v2, 3)\n    #DriveTrainMoveandStop(140, REVERSE, 80, 1)\n    wait(0.1, SECONDS)\n    PStraight(120, 120, v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(90, v1, 8)\n\ndef KnockDownRed2(v1, v2):\n    GyroTurn(150, v1, 8)\n    wait(0.1, SECONDS)\n    PStraight(-130, 150, -v2, 3)\n    #DriveTrainMoveandStop(140, REVERSE, 80, 1)\n    wait(0.1, SECONDS)\n    PStraight(200, 150, v2, 3)\n\ndef Turn90andIntake(v1, v2):\n    GyroTurn(90, v1, 8)\n    wait(0.5, SECONDS)\n    PStraight(450, 90, v2, 3)\n    wait(0.1, SECONDS)\n    KnockDownRed1(60, 60)\n    wait(0.1, SECONDS)\n    PStraight(200, 90, v2, 3)\n    wait(0.1, SECONDS)\n    PStraight(100, 90, 60, 3)\n    KnockDownRed2(60, 60)\n    wait(0.1, SECONDS)\n\ndef Intake4Greens2(v1,v2):\n    GyroTurn(180, v1, 8)\n    wait(0.1, SECONDS)\n    PStraight(300, 180, v2, 3)\n    wait(0.1, SECONDS)\n\ndef DumpPurple(v1,v2):\n    PStraight(-165, 180, -v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(220, v1, 8)\n    wait(0.1, SECONDS)\n    # intake.spin(FORWARD)\n    # wait(0.1, SECONDS)\n    PStraight(-200, 220, -v2, 3)\n    intake_motor_a.stop()\n    intake_motor_b.stop()\n    DriveTrainMoveandStop(850, REVERSE, 80, 2)\n    elevator.spin_for(FORWARD, 1.2, TURNS)\n    wait(1,SECONDS)\n    DriveTrainMoveandStop(20, FORWARD, 80, 1)\n    DriveTrainMoveandStop(30, REVERSE, 100, 1)\n\ndef DumpGreen1(v1,v2):\n    PStraight(200, 190, v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(215, v1, 8)\n    wait(0.1, SECONDS)\n    PStraight(1000, 215, v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(290, v1, 8)\n    wait(0.1, SECONDS)\n    PStraight(-400, 290, -v2, 3)\n    DriveTrainMoveandStop(850, REVERSE, 80, 1)\n    elevator.spin_for(FORWARD, 1.9, TURNS)\n    elevator.spin_for(REVERSE, 1, TURNS)\n    # DriveTrainMoveandStop(20, FORWARD, 80, 1)\n    # DriveTrainMoveandStop(30, REVERSE, 100, 1)\n\ndef ParkAfterGreen1(v1, v2):\n    PStraightHold(1300, 280, v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(312, v1, 8)\n    wait(0.1, SECONDS)\n    PStraightHold(400, 312, v2, 3)\n    wait(0.1, SECONDS)\n    GyroTurn(385, v1, 8)\n    wait(0.1, SECONDS)\n    DriveTrainMove(1850, FORWARD, v2, 1)\n    wait(0.1, SECONDS)\n\ndef DumpGreen2():\n    DriveTrainMoveandStop(1600, REVERSE, 70, 2)\n    elevator.spin_for(FORWARD, 1, TURNS)\n    wait(1, SECONDS)\n    # DriveTrainMoveandStop(20, FORWARD, 80, 1)\n    # DriveTrainMoveandStop(30, REVERSE, 100, 1)\n    DriveTrainMove(600, FORWARD, 100, 3)\n\n#------------------------------------------------------------#\n# GyroTurn(heading_angle, heading_velocity, heading_momentum)#\n# PStraight(distance, heading, velocity, kp)                 #\n#------------------------------------------------------------#\n\ngyro_6.calibrate(GyroCalibrationType.EXTENDED)\ntouchled_4.set_color(Color.RED)\n\nwhile not touchled_4.pressing():\n    wait(0.1, SECONDS);\ntouchled_4.set_color(Color.GREEN)\n\nprepMotors()\nIntake4Greens1(35)\nTurn90andIntake(60,30)\nIntake4Greens2(60,30)\nDumpPurple(60,60)\nDumpGreen1(60,60)\nParkAfterGreen1(60,80)\nDumpGreen2()\n\n# elevator.spin_for(FORWARD, 1.2, TURNS)\n# wait(1, SECONDS)\n# elevator.spin_for(FORWARD, 1.9, TURNS)\n# wait(1, SECONDS)\n# elevator.spin_for(REVERSE, 1, TURNS)\n# wait(1, SECONDS)\n# elevator.spin_for(FORWARD, 1, TURNS)\n\n\n# touchled_4.set_color(Color.YELLOW)\n# while not touchled_4.pressing():\n#     wait(0.1, SECONDS);\n# touchled_4.set_color(Color.YELLOW_GREEN)\n# elevator.spin_for(REVERSE, 2, TURNS)\n# elevator_motor_a.stop()\n# elevator_motor_b.stop()\n\n\n\n\n\n#elevator for purple is 2\n#elevator for green is 3.15","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[1,7,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[6],"name":"gyro_6","customName":false,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[3,9],"name":"intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[2,8],"name":"elevator","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[4],"name":"touchled_4","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":4,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}